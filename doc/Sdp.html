<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="Start" href="index.html">
<link rel="previous" href="Scalar.html">
<link rel="next" href="Sdp_default.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Csdp" rel="Chapter" href="Csdp.html">
<link title="Dualize" rel="Chapter" href="Dualize.html">
<link title="Ident" rel="Chapter" href="Ident.html">
<link title="LinExpr" rel="Chapter" href="LinExpr.html">
<link title="Lmi" rel="Chapter" href="Lmi.html">
<link title="Matrix" rel="Chapter" href="Matrix.html">
<link title="Monomial" rel="Chapter" href="Monomial.html">
<link title="Moseksdp" rel="Chapter" href="Moseksdp.html">
<link title="NewtonPolytope" rel="Chapter" href="NewtonPolytope.html">
<link title="Osdp_top" rel="Chapter" href="Osdp_top.html">
<link title="Polynomial" rel="Chapter" href="Polynomial.html">
<link title="Posdef" rel="Chapter" href="Posdef.html">
<link title="PreSdp" rel="Chapter" href="PreSdp.html">
<link title="Scalar" rel="Chapter" href="Scalar.html">
<link title="Sdp" rel="Chapter" href="Sdp.html">
<link title="Sdp_default" rel="Chapter" href="Sdp_default.html">
<link title="Sdpa" rel="Chapter" href="Sdpa.html">
<link title="SdpRet" rel="Chapter" href="SdpRet.html">
<link title="Sos" rel="Chapter" href="Sos.html">
<link title="Utils" rel="Chapter" href="Utils.html"><link title="Block diagonal sparse and dense symmetric matrices." rel="Section" href="#2_Blockdiagonalsparseanddensesymmetricmatrices">
<link title="SDP." rel="Section" href="#2_SDP">
<link title="Extended formulation." rel="Section" href="#2_Extendedformulation">
<link title="Printing functions." rel="Section" href="#2_Printingfunctions">
<link title="Miscellaneous functions." rel="Section" href="#2_Miscellaneousfunctions">
<title>Sdp</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Scalar.html" title="Scalar">Previous</a>
&nbsp;<a class="up" href="index.html" title="Index">Up</a>
&nbsp;<a class="post" href="Sdp_default.html" title="Sdp_default">Next</a>
</div>
<h1>Module <a href="type_Sdp.html">Sdp</a></h1>

<pre><span id="MODULESdp"><span class="keyword">module</span> Sdp</span>: <code class="code">sig</code> <a href="Sdp.html">..</a> <code class="code">end</code></pre><div class="info module top">
<div class="info-desc">
<p><b>Common interface for SDP</b> (<a href="./Csdp.html">Csdp</a> or
    <a href="./Moseksdp.html">Moseksdp</a> or <a href="./Sdpa.html">Sdpa</a>).</p>
</div>
</div>
<hr width="100%">
<p>Primal-dual correspondence: the primal problem</p>
<pre class="codepre"><code class="code">max tr(C X)
    tr(A_1 X) = b_1
    .
    .
    .
    tr(A_m X) = b_m
    X psd</code></pre><p>(X psd meaning X positive semi-definite)
    corresponds to the dual problem</p>
<pre class="codepre"><code class="code">min b^T y
    \sum_i y_i A_i - C = Z psd</code></pre><p>where C, A_i and X are symmetric matrices, C, A_i and b_i are
    parameters whereas X (resp. y) is the primal (resp. dual)
    variable.</p>
<h3 id="2_Blockdiagonalsparseanddensesymmetricmatrices">Block diagonal sparse and dense symmetric matrices.</h3>
<pre><span id="TYPEsparse_matrix"><span class="keyword">type</span> <code class="type"></code>sparse_matrix</span> = <code class="type">(int * int * float) list</code> </pre>
<div class="info ">
<div class="info-desc">
<p>Matrices. Sparse representation as triplet <code class="code">(i, j, x)</code> meaning
    that the coefficient at line <code class="code">i</code> &gt;= 0 and column <code class="code">j</code> &gt;= 0 has
    value <code class="code">x</code>. All forgotten coefficients are assumed to be
    <code class="code">0.0</code>. Since matrices are symmetric, only the lower triangular
    part (j &lt;= i) must be given. No duplicates are allowed.</p>
</div>
</div>


<pre><span id="TYPEmatrix"><span class="keyword">type</span> <code class="type"></code>matrix</span> = <code class="type">float array array</code> </pre>
<div class="info ">
<div class="info-desc">
<p>Matrices. Dense representation, line by line. Must be symmetric.
    Type invariant: all lines have the same size.</p>
</div>
</div>


<pre><span id="TYPEblock_diag"><span class="keyword">type</span> <code class="type">'a</code> block_diag</span> = <code class="type">(int * 'a) list</code> </pre>
<div class="info ">
<div class="info-desc">
<p>Block diagonal matrices (sparse representation, forgetting null
    blocks). For instance, <code class="code">[(1, m1), (3, m2)]</code> will be transformed
    into <code class="code">[m1; 0; m2]</code>. No duplicates are allowed. There is no
    requirement for indices to be sorted.</p>
</div>
</div>


<pre><span id="VALmatrix_of_sparse"><span class="keyword">val</span> matrix_of_sparse</span> : <code class="type"><a href="Sdp.html#TYPEsparse_matrix">sparse_matrix</a> -> <a href="Sdp.html#TYPEmatrix">matrix</a></code></pre>
<pre><span id="VALmatrix_to_sparse"><span class="keyword">val</span> matrix_to_sparse</span> : <code class="type"><a href="Sdp.html#TYPEmatrix">matrix</a> -> <a href="Sdp.html#TYPEsparse_matrix">sparse_matrix</a></code></pre>
<pre><span id="VALblock_diag_of_sparse"><span class="keyword">val</span> block_diag_of_sparse</span> : <code class="type"><a href="Sdp.html#TYPEsparse_matrix">sparse_matrix</a> <a href="Sdp.html#TYPEblock_diag">block_diag</a> -> <a href="Sdp.html#TYPEmatrix">matrix</a> <a href="Sdp.html#TYPEblock_diag">block_diag</a></code></pre>
<pre><span id="VALblock_diag_to_sparse"><span class="keyword">val</span> block_diag_to_sparse</span> : <code class="type"><a href="Sdp.html#TYPEmatrix">matrix</a> <a href="Sdp.html#TYPEblock_diag">block_diag</a> -> <a href="Sdp.html#TYPEsparse_matrix">sparse_matrix</a> <a href="Sdp.html#TYPEblock_diag">block_diag</a></code></pre><h3 id="2_SDP">SDP.</h3>
<pre><span id="TYPEsolver"><span class="keyword">type</span> <code class="type"></code>solver</span> = <code class="type"><a href="Sdp_default.html#TYPEsolver">Sdp_default.solver</a></code> = </pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTsolver.Csdp"><span class="constructor">Csdp</span></span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTsolver.Mosek"><span class="constructor">Mosek</span></span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTsolver.Sdpa"><span class="constructor">Sdpa</span></span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTsolver.SdpaGmp"><span class="constructor">SdpaGmp</span></span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTsolver.SdpaDd"><span class="constructor">SdpaDd</span></span></code></td>

</tr></table>



<pre><code><span id="TYPEoptions"><span class="keyword">type</span> <code class="type"></code>options</span> = {</code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELToptions.solver">solver</span>&nbsp;: <code class="type"><a href="Sdp.html#TYPEsolver">solver</a></code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>default: see <a href="./Sdp_default.html">Sdp_default</a></p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELToptions.verbose">verbose</span>&nbsp;: <code class="type">int</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>verbosity level, non negative integer, 0 (default)
                      means no output (only for SDPA* and Mosek)</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELToptions.max_iteration">max_iteration</span>&nbsp;: <code class="type">int</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>maxIteration (default: 100)</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELToptions.stop_criterion">stop_criterion</span>&nbsp;: <code class="type">float</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>epsilonStar and epsilonDash (default: 1.0E-7)</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELToptions.initial">initial</span>&nbsp;: <code class="type">float</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>lambdaStar (default: 1.0E2)</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELToptions.precision">precision</span>&nbsp;: <code class="type">int</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>precision (only for SDPA-GMP, default: 200)</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>
<code>}</code>

<div class="info ">
<div class="info-desc">
<p>Options for calling SDP solvers (currently, options other than
    solver are only handled by Sdpa{,Gmp}).</p>
</div>
</div>


<pre><span id="VALdefault"><span class="keyword">val</span> default</span> : <code class="type"><a href="Sdp.html#TYPEoptions">options</a></code></pre><div class="info ">
<div class="info-desc">
<p>Default values above.</p>
</div>
</div>

<pre><span id="TYPEobj"><span class="keyword">type</span> <code class="type">'a</code> obj</span> = <code class="type">'a <a href="Sdp.html#TYPEblock_diag">block_diag</a></code> </pre>
<div class="info ">
<div class="info-desc">
<p>Objective (matrix C).</p>
</div>
</div>


<pre><code><span id="TYPEconstr"><span class="keyword">type</span> <code class="type">'a</code> constr</span> = </code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTconstr.Eq"><span class="constructor">Eq</span></span> <span class="keyword">of</span> <code class="type">'a <a href="Sdp.html#TYPEblock_diag">block_diag</a> * float</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTconstr.Le"><span class="constructor">Le</span></span> <span class="keyword">of</span> <code class="type">'a <a href="Sdp.html#TYPEblock_diag">block_diag</a> * float</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTconstr.Ge"><span class="constructor">Ge</span></span> <span class="keyword">of</span> <code class="type">'a <a href="Sdp.html#TYPEblock_diag">block_diag</a> * float</code></code></td>

</tr></table>

<div class="info ">
<div class="info-desc">
<p>Constraints (tr(A_i X) = b_i), <code class="code">Le (A_i, b_i)</code> means tr(A_i X) &lt;=
    b_i and will automatically be translated internally as tr(A_i X) +
    s_i = b_i by adding slack variables s_i &gt;= 0. Similarly <code class="code">Ge (A_i,
    b_i)</code> means tr(A_i X) &gt;= b_i and gives tr(A_i X) - s_i = b_i with
    s_i &gt;= 0.</p>
</div>
</div>


<pre><span id="VALsolve_sparse"><span class="keyword">val</span> solve_sparse</span> : <code class="type">?options:<a href="Sdp.html#TYPEoptions">options</a> -><br>       ?solver:<a href="Sdp.html#TYPEsolver">solver</a> -><br>       ?init:<a href="Sdp.html#TYPEmatrix">matrix</a> <a href="Sdp.html#TYPEblock_diag">block_diag</a> * float array * <a href="Sdp.html#TYPEmatrix">matrix</a> <a href="Sdp.html#TYPEblock_diag">block_diag</a> -><br>       <a href="Sdp.html#TYPEsparse_matrix">sparse_matrix</a> <a href="Sdp.html#TYPEobj">obj</a> -><br>       <a href="Sdp.html#TYPEsparse_matrix">sparse_matrix</a> <a href="Sdp.html#TYPEconstr">constr</a> list -><br>       <a href="SdpRet.html#TYPEt">SdpRet.t</a> * (float * float) *<br>       (<a href="Sdp.html#TYPEmatrix">matrix</a> <a href="Sdp.html#TYPEblock_diag">block_diag</a> * float array * <a href="Sdp.html#TYPEmatrix">matrix</a> <a href="Sdp.html#TYPEblock_diag">block_diag</a>)</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">solve_sparse obj constraints</code> solves the SDP problem: max{
    tr(obj X) | constraints, X psd }. If <code class="code">solver</code> is provided, it
    will supersed the solver given in <code class="code">options</code>. It returns both the
    primal and dual objective values and a witness for X (primal) and
    y and Z (dual). See above for details. There is no requirement for
    indices in <code class="code">obj</code> and <code class="code">A_i</code> to be present in every input. In case
    of success (or partial success), the block diagonal matrices
    returned for X and Z contain exactly the indices, sorted by
    increasing order, that appear in the objective or one of the
    constraints. Size of each diagonal block in X is the maximum size
    appearing for that block in the objective or one of the
    constraints. In case of success (or partial success), the array
    returned for y has the same size and same order than the input
    list of constraints.</p>
</div>
<ul class="info-attributes">
<li><b>Raises</b> <code>Invalid_argument</code> "non symmetric matrix" in case the
    objective or one of the constraints is non symmetric.</li>
</ul>
</div>

<pre><span id="VALsolve"><span class="keyword">val</span> solve</span> : <code class="type">?options:<a href="Sdp.html#TYPEoptions">options</a> -><br>       ?solver:<a href="Sdp.html#TYPEsolver">solver</a> -><br>       ?init:<a href="Sdp.html#TYPEmatrix">matrix</a> <a href="Sdp.html#TYPEblock_diag">block_diag</a> * float array * <a href="Sdp.html#TYPEmatrix">matrix</a> <a href="Sdp.html#TYPEblock_diag">block_diag</a> -><br>       <a href="Sdp.html#TYPEmatrix">matrix</a> <a href="Sdp.html#TYPEobj">obj</a> -><br>       <a href="Sdp.html#TYPEmatrix">matrix</a> <a href="Sdp.html#TYPEconstr">constr</a> list -><br>       <a href="SdpRet.html#TYPEt">SdpRet.t</a> * (float * float) *<br>       (<a href="Sdp.html#TYPEmatrix">matrix</a> <a href="Sdp.html#TYPEblock_diag">block_diag</a> * float array * <a href="Sdp.html#TYPEmatrix">matrix</a> <a href="Sdp.html#TYPEblock_diag">block_diag</a>)</code></pre><div class="info ">
<div class="info-desc">
<p>Same as <a href="Sdp.html#VALsolve_sparse"><code class="code">Sdp.solve_sparse</code></a> with dense matrices as input. This can be
    more convenient for small problems. Otherwise, this is equivalent
    to <a href="Sdp.html#VALsolve_sparse"><code class="code">Sdp.solve_sparse</code></a> after conversion with <a href="Sdp.html#VALmatrix_to_sparse"><code class="code">Sdp.matrix_to_sparse</code></a>. If
    an indice is present in one input, potential matrices for that
    indice in other inputs will be padded with 0 on right and bottom
    to have the same size.</p>
</div>
<ul class="info-attributes">
<li><b>Raises</b> <code>Invalid_argument</code> "non symmetric matrix" in case the
    objective or one of the constraints is not a sparse matrix.</li>
</ul>
</div>
<h3 id="2_Extendedformulation">Extended formulation.</h3><p>Primal-dual correspondence: the primal problem</p>
<pre class="codepre"><code class="code">max c^T x + tr(C X)
    b_1^- &lt;= a_1^T x + tr(A_1 X) &lt;= b_1^+
    .
    .
    .
    b_m^- &lt;= a_m^T x + tr(A_m X) &lt;= b_m^+
    d_1^- &lt;= x_1 &lt;= d_1^+
    .
    .
    .
    d_n^- &lt;= x_n &lt;= d_n^+
    X psd</code></pre><p>(X psd meaning X positive semi-definite)
    corresponds to the dual problem</p>
<pre class="codepre"><code class="code">min (b^+)^T s^+ - (b^-)^T s^- + (d^+)^T t^+ - (d^-)^T t^-
    y = s^+ - s^-
    \sum_i y_i A_i - C = Z psd
    [a_1,..., a_n] y - c + t^+ - t^- = 0
    s^+, s^-, t^+, t^- &gt;= 0</code></pre><p>where C, A_i and X are symmetric matrices, C, A_i, a_i, b_i and d
    are parameters whereas x, X, y, s^+, s^-, t^+ and t^- are
    variables.</p>

<p>Note that the simple formulation on top is a particular case of
    this for n = 0 and b^- = b^+.</p>

<p>The bounds b_i^- and d_j^- (resp. b_i^+ and d_j^+) can be
    <code class="code">neg_infinity</code> (resp. <code class="code">infinity</code>), in which case, the
    corresponding s or t in the dual is 0 (and the corresponding term
    disappears from the dual objective).</p>

<pre><span id="TYPEvector"><span class="keyword">type</span> <code class="type"></code>vector</span> = <code class="type">(int * float) list</code> </pre>
<div class="info ">
<div class="info-desc">
<p>No duplicates are allowed.</p>
</div>
</div>


<pre><span id="TYPEobj_ext"><span class="keyword">type</span> <code class="type">'a</code> obj_ext</span> = <code class="type"><a href="Sdp.html#TYPEvector">vector</a> * 'a <a href="Sdp.html#TYPEblock_diag">block_diag</a></code> </pre>
<div class="info ">
<div class="info-desc">
<p>Objective (vector c and matrix C).</p>
</div>
</div>


<pre><span id="TYPEconstr_ext"><span class="keyword">type</span> <code class="type">'a</code> constr_ext</span> = <code class="type"><a href="Sdp.html#TYPEvector">vector</a> * 'a <a href="Sdp.html#TYPEblock_diag">block_diag</a> * float * float</code> </pre>
<div class="info ">
<div class="info-desc">
<p>Constraints. <code class="code">(a_i, A_i, b_i_m, b_i_p)</code> encodes the constraint
    b_i_m &lt;= a_i^T x + tr(A_i X) &lt;= b_i_p. <code class="code">b_i_m</code> can be
    <code class="code">neg_infinity</code> and <code class="code">b_i_p</code> can be <code class="code">infinity</code>.</p>
</div>
</div>


<pre><span id="TYPEbounds"><span class="keyword">type</span> <code class="type"></code>bounds</span> = <code class="type">(int * float * float) list</code> </pre>
<div class="info ">
<div class="info-desc">
<p>Bounds on scalar variables. Each <code class="code">(i, lb, ub)</code> in the list encodes
    the constraint lb &lt;= x_i &lt;= ub. <code class="code">lb</code> can be <code class="code">neg_infinity</code> and
    <code class="code">ub</code> can be <code class="code">infinity</code>. No duplicated indices i are allowed.</p>
</div>
</div>


<pre><span id="VALsolve_ext_sparse"><span class="keyword">val</span> solve_ext_sparse</span> : <code class="type">?options:<a href="Sdp.html#TYPEoptions">options</a> -><br>       ?solver:<a href="Sdp.html#TYPEsolver">solver</a> -><br>       <a href="Sdp.html#TYPEsparse_matrix">sparse_matrix</a> <a href="Sdp.html#TYPEobj_ext">obj_ext</a> -><br>       <a href="Sdp.html#TYPEsparse_matrix">sparse_matrix</a> <a href="Sdp.html#TYPEconstr_ext">constr_ext</a> list -><br>       <a href="Sdp.html#TYPEbounds">bounds</a> -><br>       <a href="SdpRet.html#TYPEt">SdpRet.t</a> * (float * float) *<br>       (<a href="Sdp.html#TYPEvector">vector</a> * <a href="Sdp.html#TYPEmatrix">matrix</a> <a href="Sdp.html#TYPEblock_diag">block_diag</a> * float array *<br>        <a href="Sdp.html#TYPEmatrix">matrix</a> <a href="Sdp.html#TYPEblock_diag">block_diag</a>)</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">solve_ext_sparse obj constraints bounds</code> solves the SDP problem:
    max{ obj | constraints, bounds, X psd }. If <code class="code">solver</code> is
    provided, it will supersed the solver given in <code class="code">options</code>. It
    returns both the primal and dual objective values and a witness
    for (x, X) (primal) and (y, Z) (dual). See above for
    details. Variables x_i not bounded in <code class="code">bounds</code> are assumed to be
    unbounded (i.e., bounded by <code class="code">neg_infinity</code> and <code class="code">infinity</code>). Bounds
    in <code class="code">bounds</code> about variables x_i not appearing in the objective or
    constraints may be ignored. There is no requirement for indices in
    <code class="code">obj</code> and <code class="code">a_i, A_i</code> to be present in every input. In case of
    success (or partial success), the vector (resp. block diagonal
    matrix) returned for x (resp. X, Z) contains exactly the indices,
    sorted by increasing order, that appear in the linear
    (resp. matrix) part of the objective or one of the
    constraints. Size of each diagonal block in X or Z is the maximum
    size appearing for that block in the objective or one of the
    constraints. In case of success (or partial success), the array
    returned for y has the same size and same order than the input
    list of constraints.</p>
</div>
<ul class="info-attributes">
<li><b>Raises</b> <code>Invalid_argument</code> "non symmetric matrix" in case the
    objective or one of the constraints is non symmetric.</li>
</ul>
</div>

<pre><span id="VALsolve_ext"><span class="keyword">val</span> solve_ext</span> : <code class="type">?options:<a href="Sdp.html#TYPEoptions">options</a> -><br>       ?solver:<a href="Sdp.html#TYPEsolver">solver</a> -><br>       <a href="Sdp.html#TYPEmatrix">matrix</a> <a href="Sdp.html#TYPEobj_ext">obj_ext</a> -><br>       <a href="Sdp.html#TYPEmatrix">matrix</a> <a href="Sdp.html#TYPEconstr_ext">constr_ext</a> list -><br>       <a href="Sdp.html#TYPEbounds">bounds</a> -><br>       <a href="SdpRet.html#TYPEt">SdpRet.t</a> * (float * float) *<br>       (<a href="Sdp.html#TYPEvector">vector</a> * <a href="Sdp.html#TYPEmatrix">matrix</a> <a href="Sdp.html#TYPEblock_diag">block_diag</a> * float array *<br>        <a href="Sdp.html#TYPEmatrix">matrix</a> <a href="Sdp.html#TYPEblock_diag">block_diag</a>)</code></pre><div class="info ">
<div class="info-desc">
<p>Same as <a href="Sdp.html#VALsolve_ext_sparse"><code class="code">Sdp.solve_ext_sparse</code></a> with dense matrices as input. This can
    be more convenient for small problems. Otherwise, this is
    equivalent to <a href="Sdp.html#VALsolve_ext_sparse"><code class="code">Sdp.solve_ext_sparse</code></a> after conversion with
    <a href="Sdp.html#VALmatrix_to_sparse"><code class="code">Sdp.matrix_to_sparse</code></a>. If an indice is present in one input,
    potential matrices for that indice in other inputs will be padded
    with 0 on right and bottom to have the same size.</p>
</div>
<ul class="info-attributes">
<li><b>Raises</b> <code>Invalid_argument</code> "non symmetric matrix" in case the
    objective or one of the constraints is not a sparse matrix.</li>
</ul>
</div>
<h3 id="2_Printingfunctions">Printing functions.</h3>
<pre><span id="VALpp_sparse_matrix"><span class="keyword">val</span> pp_sparse_matrix</span> : <code class="type">Stdlib.Format.formatter -> <a href="Sdp.html#TYPEsparse_matrix">sparse_matrix</a> -> unit</code></pre>
<pre><span id="VALpp_matrix"><span class="keyword">val</span> pp_matrix</span> : <code class="type">Stdlib.Format.formatter -> <a href="Sdp.html#TYPEmatrix">matrix</a> -> unit</code></pre>
<pre><span id="VALpp_block_diag"><span class="keyword">val</span> pp_block_diag</span> : <code class="type">(Stdlib.Format.formatter -> 'a -> unit) -><br>       Stdlib.Format.formatter -> 'a <a href="Sdp.html#TYPEblock_diag">block_diag</a> -> unit</code></pre>
<pre><span id="VALpp_obj"><span class="keyword">val</span> pp_obj</span> : <code class="type">(Stdlib.Format.formatter -> 'a -> unit) -><br>       Stdlib.Format.formatter -> 'a <a href="Sdp.html#TYPEobj">obj</a> -> unit</code></pre>
<pre><span id="VALpp_constr"><span class="keyword">val</span> pp_constr</span> : <code class="type">(Stdlib.Format.formatter -> 'a -> unit) -><br>       Stdlib.Format.formatter -> 'a <a href="Sdp.html#TYPEconstr">constr</a> -> unit</code></pre>
<pre><span id="VALpp_sparse"><span class="keyword">val</span> pp_sparse</span> : <code class="type">Stdlib.Format.formatter -><br>       <a href="Sdp.html#TYPEsparse_matrix">sparse_matrix</a> <a href="Sdp.html#TYPEobj">obj</a> * <a href="Sdp.html#TYPEsparse_matrix">sparse_matrix</a> <a href="Sdp.html#TYPEconstr">constr</a> list -> unit</code></pre>
<pre><span id="VALpp"><span class="keyword">val</span> pp</span> : <code class="type">Stdlib.Format.formatter -><br>       <a href="Sdp.html#TYPEmatrix">matrix</a> <a href="Sdp.html#TYPEobj">obj</a> * <a href="Sdp.html#TYPEmatrix">matrix</a> <a href="Sdp.html#TYPEconstr">constr</a> list -> unit</code></pre>
<pre><span id="VALpp_vector"><span class="keyword">val</span> pp_vector</span> : <code class="type">Stdlib.Format.formatter -> <a href="Sdp.html#TYPEvector">vector</a> -> unit</code></pre>
<pre><span id="VALpp_obj_ext"><span class="keyword">val</span> pp_obj_ext</span> : <code class="type">(Stdlib.Format.formatter -> 'a -> unit) -><br>       Stdlib.Format.formatter -> 'a <a href="Sdp.html#TYPEobj_ext">obj_ext</a> -> unit</code></pre>
<pre><span id="VALpp_constr_ext"><span class="keyword">val</span> pp_constr_ext</span> : <code class="type">(Stdlib.Format.formatter -> 'a -> unit) -><br>       Stdlib.Format.formatter -> 'a <a href="Sdp.html#TYPEconstr_ext">constr_ext</a> -> unit</code></pre>
<pre><span id="VALpp_bounds"><span class="keyword">val</span> pp_bounds</span> : <code class="type">Stdlib.Format.formatter -> <a href="Sdp.html#TYPEbounds">bounds</a> -> unit</code></pre>
<pre><span id="VALpp_ext_sparse"><span class="keyword">val</span> pp_ext_sparse</span> : <code class="type">Stdlib.Format.formatter -><br>       <a href="Sdp.html#TYPEsparse_matrix">sparse_matrix</a> <a href="Sdp.html#TYPEobj_ext">obj_ext</a> * <a href="Sdp.html#TYPEsparse_matrix">sparse_matrix</a> <a href="Sdp.html#TYPEconstr_ext">constr_ext</a> list *<br>       <a href="Sdp.html#TYPEbounds">bounds</a> -> unit</code></pre>
<pre><span id="VALpp_ext"><span class="keyword">val</span> pp_ext</span> : <code class="type">Stdlib.Format.formatter -><br>       <a href="Sdp.html#TYPEmatrix">matrix</a> <a href="Sdp.html#TYPEobj_ext">obj_ext</a> * <a href="Sdp.html#TYPEmatrix">matrix</a> <a href="Sdp.html#TYPEconstr_ext">constr_ext</a> list * <a href="Sdp.html#TYPEbounds">bounds</a> -> unit</code></pre>
<pre><span id="VALpp_ext_sparse_sedumi"><span class="keyword">val</span> pp_ext_sparse_sedumi</span> : <code class="type">Stdlib.Format.formatter -><br>       <a href="Sdp.html#TYPEsparse_matrix">sparse_matrix</a> <a href="Sdp.html#TYPEobj_ext">obj_ext</a> * <a href="Sdp.html#TYPEsparse_matrix">sparse_matrix</a> <a href="Sdp.html#TYPEconstr_ext">constr_ext</a> list *<br>       <a href="Sdp.html#TYPEbounds">bounds</a> -> unit</code></pre>
<pre><span id="VALpp_ext_sedumi"><span class="keyword">val</span> pp_ext_sedumi</span> : <code class="type">Stdlib.Format.formatter -><br>       <a href="Sdp.html#TYPEmatrix">matrix</a> <a href="Sdp.html#TYPEobj_ext">obj_ext</a> * <a href="Sdp.html#TYPEmatrix">matrix</a> <a href="Sdp.html#TYPEconstr_ext">constr_ext</a> list * <a href="Sdp.html#TYPEbounds">bounds</a> -> unit</code></pre><h3 id="2_Miscellaneousfunctions">Miscellaneous functions.</h3>
<pre><span id="VALpfeas_stop_crit"><span class="keyword">val</span> pfeas_stop_crit</span> : <code class="type">?options:<a href="Sdp.html#TYPEoptions">options</a> -> ?solver:<a href="Sdp.html#TYPEsolver">solver</a> -> float list -> float</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">pfeas_stop_crit (b_1,..., b_m)</code> returns <code class="code">eps</code> used as primal
    feasibility error stopping criteria by solver <code class="code">solver</code> on a
    problem with given <code class="code">b_i</code> (i.e., if the solver successfully
    terminates, |tr(A_i X) - b_i| &lt;= eps should hold for each
    constraint i).</p>
</div>
</div>
</body></html>
