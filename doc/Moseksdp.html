<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="Start" href="index.html">
<link rel="previous" href="Monomial.html">
<link rel="next" href="NewtonPolytope.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Csdp" rel="Chapter" href="Csdp.html">
<link title="Dualize" rel="Chapter" href="Dualize.html">
<link title="Ident" rel="Chapter" href="Ident.html">
<link title="LinExpr" rel="Chapter" href="LinExpr.html">
<link title="Lmi" rel="Chapter" href="Lmi.html">
<link title="Matrix" rel="Chapter" href="Matrix.html">
<link title="Monomial" rel="Chapter" href="Monomial.html">
<link title="Moseksdp" rel="Chapter" href="Moseksdp.html">
<link title="NewtonPolytope" rel="Chapter" href="NewtonPolytope.html">
<link title="Osdp_top" rel="Chapter" href="Osdp_top.html">
<link title="Polynomial" rel="Chapter" href="Polynomial.html">
<link title="Posdef" rel="Chapter" href="Posdef.html">
<link title="PreSdp" rel="Chapter" href="PreSdp.html">
<link title="Scalar" rel="Chapter" href="Scalar.html">
<link title="Sdp" rel="Chapter" href="Sdp.html">
<link title="Sdp_default" rel="Chapter" href="Sdp_default.html">
<link title="Sdpa" rel="Chapter" href="Sdpa.html">
<link title="SdpRet" rel="Chapter" href="SdpRet.html">
<link title="Sos" rel="Chapter" href="Sos.html">
<link title="Utils" rel="Chapter" href="Utils.html"><title>Moseksdp</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Monomial.html" title="Monomial">Previous</a>
&nbsp;<a class="up" href="index.html" title="Index">Up</a>
&nbsp;<a class="post" href="NewtonPolytope.html" title="NewtonPolytope">Next</a>
</div>
<h1>Module <a href="type_Moseksdp.html">Moseksdp</a></h1>

<pre><span id="MODULEMoseksdp"><span class="keyword">module</span> Moseksdp</span>: <code class="code">sig</code> <a href="Moseksdp.html">..</a> <code class="code">end</code></pre><div class="info module top">
<div class="info-desc">
<p>Interface towards the C library of Mosek for SDP.</p>

<p>Mosek SDP is a semidefinite programming optimization
    procedure. You may be interested in the slightly higher level
    interface <a href="./Sdp.html">Sdp</a>.</p>
</div>
</div>
<hr width="100%">
<p>See  <a href="./Sdp.html">Sdp</a> for definitions of SDP with primal and dual.</p>

<pre><span id="TYPEmatrix"><span class="keyword">type</span> <code class="type"></code>matrix</span> = <code class="type">(int * int * float) list</code> </pre>
<div class="info ">
<div class="info-desc">
<p>Matrices. Sparse representation as triplet <code class="code">(i, j, x)</code> meaning
    that the coefficient at line <code class="code">i</code> &gt;= 0 and column <code class="code">j</code> &gt;= 0 has
    value <code class="code">x</code>. All forgotten coefficients are assumed to be
    <code class="code">0.0</code>. Since matrices are symmetric, only the lower triangular
    part (j &lt;= i) must be given. No duplicates are allowed.</p>
</div>
</div>


<pre><span id="TYPEblock_diag_matrix"><span class="keyword">type</span> <code class="type"></code>block_diag_matrix</span> = <code class="type">(int * <a href="Moseksdp.html#TYPEmatrix">matrix</a>) list</code> </pre>
<div class="info ">
<div class="info-desc">
<p>Block diagonal matrices (sparse representation, forgetting null
    blocks). For instance, <code class="code">[(1, m1), (3, m2)]</code> will be transformed
    into <code class="code">[m1; 0; m2]</code>. No duplicates are allowed. There is no
    requirement for indices to be sorted.</p>
</div>
</div>


<pre><code><span id="TYPEoptions"><span class="keyword">type</span> <code class="type"></code>options</span> = {</code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELToptions.verbose">verbose</span>&nbsp;: <code class="type">int</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>verbosity level, non negative integer, 0 (default)
                      means no output</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>
<code>}</code>

<div class="info ">
<div class="info-desc">
<p>Options for calling MOSEK.</p>
</div>
</div>


<pre><span id="VALdefault"><span class="keyword">val</span> default</span> : <code class="type"><a href="Moseksdp.html#TYPEoptions">options</a></code></pre><div class="info ">
<div class="info-desc">
<p>Default values above.</p>
</div>
</div>

<pre><span id="VALsolve"><span class="keyword">val</span> solve</span> : <code class="type">?options:<a href="Moseksdp.html#TYPEoptions">options</a> -><br>       <a href="Moseksdp.html#TYPEblock_diag_matrix">block_diag_matrix</a> -><br>       (<a href="Moseksdp.html#TYPEblock_diag_matrix">block_diag_matrix</a> * float) list -><br>       <a href="SdpRet.html#TYPEt">SdpRet.t</a> * (float * float) *<br>       ((int * float array array) list * float array *<br>        (int * float array array) list)</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">solve obj constraints</code> solves the SDP problem: max{ tr(obj X) |
    tr(A_1 X) = a_1,..., tr(A_m X) = a_m, X psd } with <code class="code">[(A_1,
    a_1);...; (A_m, a_m)]</code> the <code class="code">constraints</code> list. It returns both
    the primal and dual objective values and a witness for X (primal)
    and y and Z (dual, see <a href="./Sdp.html">Sdp</a>). In case of success (or
    partial success), the block diagonal matrices returned for X and Z
    contain exactly the indices, sorted by increasing order, that
    appear in the objective or one of the constraints. Size of each
    diagonal block in X or Z is the maximum size appearing for that
    block in the objective or one of the constraints. In case of
    success (or partial success), the array returned for y has the
    same size and same order than the input list of constraints.</p>
</div>
</div>

<pre><span id="VALsolve_ext"><span class="keyword">val</span> solve_ext</span> : <code class="type">?options:<a href="Moseksdp.html#TYPEoptions">options</a> -><br>       (int * float) list * <a href="Moseksdp.html#TYPEblock_diag_matrix">block_diag_matrix</a> -><br>       ((int * float) list * <a href="Moseksdp.html#TYPEblock_diag_matrix">block_diag_matrix</a> * float * float) list -><br>       (int * float * float) list -><br>       <a href="SdpRet.html#TYPEt">SdpRet.t</a> * (float * float) *<br>       ((int * float) list * (int * float array array) list * float array *<br>        (int * float array array) list)</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">solve obj constraints</code> solves the SDP problem: max{ c^T x +
    tr(obj X) | b_1^- &lt;= a_1^T x + tr(A_1 X) &lt;= a_1^+,..., b_m^- &lt;=
    a_m x + tr(A_m X) &lt;= b_m^+, d_1^- &lt;= x_1 &lt;= d_1^+,..., d_n^- &lt;=
    x_n &lt;= d_n^+, X psd } with <code class="code">[(a_1, A_1, b_1^-, b_1^+);...; (a_m,
    A_m, b_m^-, b_m^+)]</code> the <code class="code">constraints</code> list and <code class="code">[(d_1^-,
    d_1^+),..., (d_n^-, d_n^+)]</code> the <code class="code">bounds</code> list (missing bounds
    are considered as <code class="code">(neg_infinity, infinity)</code>, bounds about
    variables x_i not appearing in the objective or constraints may be
    ignored). It returns both the primal and dual objective values and
    a witness for (x, X) (primal) and (y, Z) (dual, see
    <a href="./Sdp.html">Sdp</a>). In case of success (or partial success), the
    vector (resp. block diagonal matrix) returned for x (resp. X)
    contains exactly the indices, sorted by increasing order, that
    appear in the linear (resp. matrix) part of the objective or one
    of the constraints. Size of each diagonal block in X or Z is the
    maximum size appearing for that block in the objective or one of
    the constraints. In case of success (or partial success), the
    array returned for y has the same size and same order than the
    input list of constraints.</p>
</div>
</div>
</body></html>
